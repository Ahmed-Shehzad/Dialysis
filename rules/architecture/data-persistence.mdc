---
description: Enforces Redis distributed cache + EF Core + PostgreSQL for persistence. Read-heavy: cache-aside. Write-heavy: persist to DB then invalidate cache.
globs: **/*.cs
---
## Data Persistence (Redis + EF Core + PostgreSQL)

### Stack
- **PostgreSQL**: Primary persistence via EF Core
- **Redis**: Distributed cache for read-heavy scenarios; fallback to `IDistributedCache` in-memory when Redis not configured
- **EF Core**: One DbContext per bounded context; migrations per service

### Read-Heavy (Cache-Aside)
1. Check cache first (`IDistributedCache` or service abstraction)
2. On miss: query PostgreSQL, serialize and store in cache with TTL
3. Return result

### Write-Heavy (Write + Invalidate)
1. Persist to PostgreSQL (insert/update)
2. Invalidate related cache keys (or update cache)
3. Subsequent reads repopulate cache from DB

### Configuration
- `ConnectionStrings:PostgreSQL` – required for services with persistence
- `ConnectionStrings:Redis` – optional; use `AddStackExchangeRedisCache` when set, else `AddDistributedMemoryCache`
- Run migrations: Development auto-migrates; Production use `dotnet ef database update` or deployment scripts

### Multi-Tenancy
- Each tenant has its own database: use `Tenancy:ConnectionStringTemplate` with `{TenantId}` placeholder
- Tenant from `X-Tenant-Id` header (default: `default`)
- Cache keys include tenant for isolation

### Service-Specific
- **Dialysis.Alerting**: `AlertDbContext`, `IAlertCacheService` – per-tenant DB; alerts list cached 2 min; create/acknowledge invalidates
